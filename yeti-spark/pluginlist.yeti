
// Dan's suggestion
//  * Vamp aubio plugins, 0.4.0 [info] [download] [download source code]

program pluginlist;

{ route, esc, link, divc, divid, elt, eltid, span, spanid } = load spag;

store = load yertle.store;
property = load yertle.property;
vamp = load may.vamp;
vamprdf = load may.vamp.vamprdf;

pluginStore = store.newRdfStore ();
vamprdf.loadSystemVampRdf pluginStore;

platformTag { headers, queryParams } =
    if "platform" in queryParams then queryParams["platform"]
    else
        ua = "User-Agent";
        if ua in headers then
            if headers[ua] =~ "Linux" then
                if headers[ua] =~ "i686" then "linux32"
                else "linux64"
                fi;
            elif headers[ua] =~ "Windows" then "win32"
            elif headers[ua] =~ "Macintosh" then "osx"
            else "unknown"
            fi
        else "unknown"
        fi
    fi;

platformName ptag =
    if ptag == "linux32" then "32-bit Linux"
    elif ptag == "linux64" then "64-bit Linux"
    elif ptag == "win32" then "Windows"
    elif ptag == "osx" then "Mac OS/X"
    else ""
    fi;

platformStatus tag pluginData =
    if tag == "unknown" then MaybeAvailable ()
    elif not empty? (find (== tag) pluginData.library.platforms) then Available ()
    elif empty? pluginData.library.platforms or pluginData.library.source then MaybeAvailable ()
    else Unavailable ()
    fi;

pluginData = 
    map (vamprdf.pluginDataByNode pluginStore)
       (vamprdf.allPluginNodes pluginStore);

//!!! should have cc:license as well

warnMissing pdata =
   (note prop =
        eprintln "**    note: \(pdata.pluginKey): Lacks \(prop)";
    libnote prop =
        eprintln "**    note: \(pdata.pluginKey): Library node lacks \(prop)";
    warn prop =
        eprintln "** WARNING: \(pdata.pluginKey): Lacks \(prop)";
    libwarn prop =
        eprintln "** WARNING: \(pdata.pluginKey): Library node lacks \(prop)";
    if pdata.name == "" then warn "dc:title" fi;
    if pdata.description == "" then warn "dc:description" fi;
    if pdata.maker == "" then warn "foaf:maker/foaf:name" fi;
    if pdata.copyright == "" then note "dc:rights" fi;
    if pdata.version == "" then note "owl:versionInfo" fi;
    if pdata.category == [] then warn "vamp:category" fi;
    if pdata.infoURL == "" then note "foaf:page" fi;
    if pdata.makerLogoURL == "" then libnote "foaf:maker/foaf:logo" fi;
    if pdata.library.name == "" then libwarn "dc:title" fi;
    if pdata.library.description == "" then libwarn "dc:description" fi;
    if pdata.library.downloadURL == "" then libwarn "doap:download-page" fi;
    if not pdata.library.source and empty? pdata.library.platforms then
        libwarn "availability";
    fi
    );

for pluginData warnMissing;

nonKeywords = mapIntoHash id id [
    "a", "and", "the", "an", "of", "plugin"
];

keywords search =
    concatMap do w:
        if w in nonKeywords or strLength w < 2 then [] else [w] fi
        done (strSplit "\\s+" search);

textSearchScore search =
   (search = strLower search;
    needles = keywords search;
    do haystack:
        haystack = strLower haystack;
        if strIndexOf haystack search 0 >= 0 then 
            2 * (if needles == [] then 1 else length needles fi)
        else
            fold do acc needle: 
                if strIndexOf haystack needle 0 >= 0 then acc + 1 else acc fi
                done 0 needles
        fi
    done);

pluginSearchScore search plugin =
   (scorer = textSearchScore search;
    3 * scorer plugin.name +
    2 * scorer plugin.library.name +
    scorer plugin.description +
    scorer plugin.library.description +
    scorer plugin.library.soname +
    scorer plugin.maker +
    fold do acc cat: acc + scorer cat done 0 plugin.category);

filterPlugins search ptag plugins =
   (found = 
        if strLength search < 2 then []
        else
            scorer = pluginSearchScore search;
            results = concatMap do p:
                score = scorer p;
                if score > 0 then
                    case platformStatus ptag p of
                    Available (): [ { score = score + 100, p } ];
                    MaybeAvailable (): [ { score = score + 50, p } ];
                    Unavailable (): [ { score, p } ];
                    esac
                else
                    []
                fi
                done plugins;
            map (.p) (sortBy do a b: a.score > b.score done results)
        fi;
    // Now produce a list of the found plugins, in the same order, but
    // with plugins from the same library grouped together (at the
    // position of the first plugin from that library)
    libs = [:];
    orderedLibs = array [];
    for found do f: 
        s = f.library.soname;
        if not s in libs then
            push orderedLibs s;
            libs[s] := true;
        fi;
    done;
    concatMap do s:
        concatMap do f:
            if s == f.library.soname then [f] else [] fi
        done found;
    done orderedLibs);

sortPlugins =
   (props = map (strLower .) [ (.maker), (.library.name), (.name) ];
    sortBy do a b:
        case (find do prop: prop a != prop b done props) of
        prop::_: prop a < prop b;
        _: false;
        esac
    done);

iriIdMap = [:];
var iriIdNext = 0;

divIdFor iri =
   synchronized iriIdMap do:
       if not iri in iriIdMap then
           iriIdMap[iri] := "piri\(iriIdNext)";
           iriIdNext := iriIdNext + 1;
       fi;
       iriIdMap[iri];
   done;

highlighted search text =
   (hlaux search text tlower =
       (ix = strIndexOf tlower search 0;
        if ix >= 0 then
            slen = strLength search;
            tlen = strLength text;
            strLeft text ix ^
                "<span class=\"highlight\">" ^ 
                strSlice text ix (ix + slen) ^
                "</span>" ^ 
                hlaux search 
                   (strSlice text (ix + slen) tlen)
                   (strSlice tlower (ix + slen) tlen);
        else
            text
        fi);
    if search == "" then text
    else 
        h = hlaux (strLower search) text (strLower text);
        if h != text then h
        else fold do acc key:
            hlaux (strLower key) acc (strLower acc)
            done text (keywords search)
        fi
    fi);

groupByLibrary = groupBy do a b: if a.libraryName == "" or b.libraryName == "" then false else a.libraryName == b.libraryName fi done;

renderSearchResult fragment =
    fragment.logo ^ fragment.libraryName ^ fragment.name;

oddEven thing = 
   (var prev = false;
      \(synchronized prev do:
            if prev then prev := false; "\(thing)-odd"
            else prev := true; "\(thing)-even" 
            fi
        done));

libOddEven = oddEven "library";
plugOddEven = oddEven "plugin";
        
renderLibraryPlugins plugins =
    case plugins of
    first::rest:
       (i = divIdFor first.data.pluginNode;
        eltid "li" "library \(libOddEven ())" "lib-\(i)"
           (divc "library-logo-name" (first.logo ^ first.libraryName) ^
            divc "library-description" first.libraryDescription ^
            divc "library-maker" first.makerName ^
            divc "library-availability" first.availability ^
            divc "library-links" first.libraryLinks ^
            "\n" ^
            eltid "ul" "plugins" "plugs-\(i)"
               (strJoin "\n"
                   (map do p:
                        elt "li" "plugin \(plugOddEven ())"
                           (divc "plugin-name" p.name ^
                            divc "plugin-category" p.category ^
                            divc "plugin-description" p.description ^
                            if p.pluginLinks != "" 
                            then divc "plugin-links" p.pluginLinks
                            else "" fi)
                    done plugins)));
        );
    _: "";
    esac;

renderSearchResults fragments =
    "<ul>\n" ^
    strJoin "\n" (map renderLibraryPlugins (groupByLibrary fragments)) ^
    "</li>\n" ^
    "</ul>\n";

renderPluginList = renderSearchResults; //!!!

route (Get "/plugin/list") do { headers, queryParams }:
    ptag = platformTag { headers, queryParams };
    pname = platformName ptag;
    eprintln "platform = \(ptag)";
    search = if "search" in queryParams then queryParams["search"] else "" fi;
    processed = (highlighted search) . esc;
    plugs = 
        if search != "" then
            filterPlugins search ptag pluginData
        else
            sortPlugins pluginData
        fi;
    fragments = map do pd:
        {
            name = elt "b" "" (processed pd.name),
            description = strReplace "\n" "<br>" (processed pd.description),
            logo =
                if pd.makerLogoURL == "" then "" 
                else
                    i = "<img class=\"maker-logo\" src=\"\(pd.makerLogoURL)\">";
                    if pd.makerInfoURL != "" then link pd.makerInfoURL i
                    else i
                    fi
                fi,
            libraryLinks = 
                if pd.library.downloadURL != "" then
                    if pd.library.infoURL != "" then
                        link pd.library.infoURL "More info" ^ " "
                    else ""
                    fi ^
                        link pd.library.downloadURL "Download"
                elif pd.library.infoURL != "" then
                    link pd.library.infoURL "More info"
                else ""
                fi,
            pluginLinks = 
                if pd.infoURL != "" then
                    link pd.infoURL "Documentation"
                else ""
                fi,
            libraryName =
                elt "b" ""
                   (processed
                        if pd.library.name == "" then pd.library.soname
                        else pd.library.name
                        fi),
            libraryDescription = processed pd.library.description,
            makerName = elt "i" "" (processed pd.maker),
            availability = 
                if pname == "" then "" 
                else 
                    case platformStatus ptag pd of
                    Available ():
                        span "availability available" "Available for \(pname)";
                    MaybeAvailable ():
                        span "availability maybe-available" "Uncertain availability for \(pname)";
                    Unavailable ():
                        span "availability unavailable" "Not available for \(pname)";
                    esac;
                fi,
            category = elt "i" "" (processed (strJoin ' > ' pd.category)),
            data = pd,
        }
    done plugs;

    "<html>" ^
    "<head>" ^
    "<link rel=\"stylesheet\" type=\"text/css\" href=\"/css/main.css\"/>" ^
    "</head>" ^
    "<body>" ^
    "<div class=\"pluginlist\">" ^
    if search != "" then
        renderSearchResults fragments
    else
        renderPluginList fragments
    fi ^
    "</div>" ^
    "</body>" ^
    "</html>";
done;

route (Get "/css/main.css") do _:
    readFile "css/main.css" "UTF-8"
        do h: strJoin "\n" (h.lines ()) done;
done;
